\documentclass[twoside,10pt]{article}

% --- Paquetes de Idioma y Codificación ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish,es-tabla]{babel} 

% --- Paquetes Matemáticos y Teoremas ---
\usepackage{amsmath, amssymb, amsthm, amsfonts}
\usepackage{mathtools}

% --- Paquetes de Diseño, Gráficos y Tablas ---
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{booktabs} 
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{authblk} 

% --- Paquetes para Código Fuente ---
\usepackage{listings}
\usepackage{xcolor}

% --- Configuración de Hipervínculos ---
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    citecolor=red,
    urlcolor=blue
}

% --- Configuración de Márgenes ---
\geometry{top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm}

% --- Definiciones Matemáticas ---
\DeclareMathOperator*{\argmin}{arg\,min}
\newtheorem{definition}{Definición}[section]
\newtheorem{theorem}{Teorema}[section]
\newtheorem{lemma}[theorem]{Lema}

% --- Estilo de Código C++ ---
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.96,0.96,0.96}

\lstdefinestyle{cppstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C++
}
\lstset{style=cppstyle}

% --- Título y Autores ---
\title{\textbf{Optimización de Red de Fibra Óptica \\ (Degree-Constrained Minimum Spanning Tree)}}

\author{Ernesto Abreu Peraza}
\author{Eduardo Brito Labrada}
\affil{Diseño y Análisis de Algoritmos - Universidad de La Habana}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
\noindent Este informe detalla el análisis e implementa soluciones al conocido problema NP-Hard Degree Constrained Minimum Spanning Tree para la infraestructura de red de la Universidad de La Habana. 
Se presenta la formalización matemática, la demostración de su complejidad computacional y una comparativa experimental entre diferentes algoritmos.
\end{abstract}

\newpage
\tableofcontents
\newpage


\section{Introducción}

El diseño eficiente de redes de comunicación constituye un problema fundamental en múltiples dominios de la ingeniería y las ciencias de la computación, particularmente en el contexto de infraestructuras físicas como redes de fibra óptica. En estos escenarios, no solo resulta relevante minimizar el costo total de interconexión, sino también respetar restricciones técnicas impuestas por el equipamiento disponible, tales como el número máximo de conexiones que puede soportar cada nodo de la red.

El problema del Árbol de Expansión Mínimo con Restricciones de Grado (\textit{Degree-Constrained Minimum Spanning Tree}, DCMST) surge de manera natural al modelar este tipo de situaciones. A diferencia del problema clásico del Árbol de Expansión Mínimo (MST), el DCMST impone cotas superiores al grado de cada vértice, lo cual incrementa significativamente su complejidad computacional. De hecho, el DCMST es un problema NP-Hard, lo que implica que, salvo que \( \text{P} = \text{NP} \), no existen algoritmos que lo resuelvan de manera eficiente para grandes instancias.

Motivado por el problema definido en este \href{https://github.com/ErnestoAbreu/daa-project/blob/main/docs/problem.md}{documento}, se realiza una formalización matemática rigurosa del problema, se analizan y se demuestra su complejidad computacional.

Adicionalmente, se diseñan e implementan varios algoritmos y se presenta un análisis experimental que permite comparar el comportamiento de las distintas estrategias implementadas.


\section{Formalización del Problema}
Partiendo de la necesidad de interconectar los edificios de la universidad minimizando costos y respetando la capacidad 
de puertos de ETECSA, definimos el modelo matemático.

\subsection{Modelo Matemático}
Sea $G = (V, E)$ un grafo conexo y no dirigido, donde:
\begin{itemize}
    \item $V$ es el conjunto de edificios.
    \item $E$ es el conjunto de posibles conexiones de fibra.
    \item $w: E \to \mathbb{R}^+$ es una función de costo.
    \item $k: V \to \mathbb{N}$ es la capacidad de puertos por edificio.
\end{itemize}

El problema consiste en encontrar un subgrafo $T = (V, E')$ tal que:
\begin{equation}
    T^* = \argmin_{T \in \mathcal{T}} \sum_{e \in E'} w(e)
\end{equation}
Sujeto a:
\begin{enumerate}
    \item $T$ es un árbol de expansión de $G$.
    \item $\forall v \in V, \text{deg}_T(v) \leq k(v)$.
\end{enumerate}

Este problema es conocido como \textit{Degree-Constrained Minimum Spanning Tree} (DCMST).

\subsection{Variantes del Problema}

Analicemos algunas variantes, las cuales surgen a partir de diferentes supuestos sobre la estructura del grafo y las 
restricciones de grado.

\subsubsection{DCMST en grafos completos}

Una variante relevante del DCMST es aquella en la que el grafo se asume completo. Formalmente, se considera un grafo no dirigido
\[
G = (V, E),
\]
donde
\[
E = \{ \{u,v\} \mid u,v \in V,\; u \neq v \}.
\]

Este modelo se ajusta bien al problema original, dado que de no existir una conexión original entre dos vértices 
(porque sea imposible conectar dos edificios), puedes asignar un costo \textit{infinito} a dicha arista, asegurando 
que no será seleccionada en la solución óptima. De ser seleccionada representaría que no se encontró solución factible.


Analizando la complejidad temporal, el carácter completo del grafo incrementa significativamente el número de aristas al peor caso,
\[
|E| = \frac{|V|(|V|-1)}{2} = O(|V|^2).
\]

\subsubsection{DCMST con restricción de grado uniforme}

Otra variante ampliamente estudiada es aquella en la que el límite de grado es uniforme para todos los vértices del grafo. 
En este caso, se fija un valor entero constante \( K \geq 2 \) tal que
\[
\deg_T(v) \leq K \quad \forall v \in V,
\]
donde \( \deg_T(v) \) denota el grado del vértice \( v \) en el árbol generador \( T \).

Esta formulación es adecuada en el caso en que el equipamiento de red sea el mismo para todos los edificios.

Además si tomamos \( K = \min_{v \in V} k(v) \), una solución optima de esta instancia es una solución factible, 
aunque no necesariamente óptima, para la instancia del problema original.

\subsubsection{Degree-Constrained Spanning Tree (DCST)}

Una variante adicional es el problema Degree-Constrained Spanning Tree. En esta versión, el objetivo no consiste en 
minimizar el peso total del árbol, sino únicamente en determinar la existencia de un árbol generador que satisfaga las 
restricciones estructurales.

Este problema puede ser formulado como un problema de decisión o factibilidad. A pesar de la ausencia de una función 
objetivo de optimización, la determinación de la existencia de una solución válida sigue siendo computacionalmente 
difícil en el caso general. Esta variante resulta de interés teórico y se emplea frecuentemente como base para el 
estudio de la complejidad del DCMST y el diseño de algoritmos exactos y aproximados.

\vspace{1em}

En la siguiente sección, se analizará la complejidad computacional del DCMST y sus variantes. En la experimentación nos 
enfocaremos principalmente analizando DCMST en grafos completos con restricción de grado uniforme por los beneficios 
planteados anteriormente.


\section{Análisis de Complejidad Computacional}

\subsection{Demostración de NP-Hardness del problema DCMST}

Para analizar la complejidad computacional del problema, demostramos que dicho problema es NP-Hard mediante una reducción 
polinomial desde el problema del Viajante de Comercio (\textit{Traveling Salesman Problem}, TSP), uno de los problemas 
clásicos NP-Hard.

\begin{theorem}
El problema Degree-Constrained Minimum Spanning Tree es NP-Hard.
\end{theorem}

\begin{proof}
Consideremos una instancia arbitraria del problema del Viajante. Dicha instancia está definida por un grafo completo no dirigido
\[
G = (V, E),
\]
junto con una función de costos \( w: E \rightarrow \mathbb{R}^+ \). El objetivo del TSP es encontrar un ciclo simple de costo 
mínimo que visite exactamente una vez cada vértice. Un ciclo simple que cubre todos los vértices es conocido como ciclo hamiltoniano.

A partir de esta instancia, construimos una instancia del problema DCMST de la siguiente manera:
\begin{itemize}
    \item Obtenemos el mismo grafo \( G = (V, E) \) y la misma función de costos \( w \).
    \item Sea \(v\) un vértice cualquiera de \(G\)
    \item Dividimos \(v\) en dos vértices \(v_1\) y \(v_2\), tal que \(k(v_1) = 1 \) y \(k(v_2) = 1\).
    \item Asignamos restricciones de grado \( k(u) = 2 \) para todo \( u \in V \setminus \{v_1 , v_2\} \).
\end{itemize}

Observemos que, bajo esta restricción, cualquier árbol de expansión válido \( T \) debe satisfacer
\[
\deg_T(v) \leq 2 \quad \forall v \in V.
\]
Un árbol de expansión con grado máximo 2 en todos los vértices es necesariamente un camino simple que cubre todos los vértices del grafo.
En todo camino simple, los vértices extremos tienen grado 1 y los vértices intermedios tienen grado 2.

Si resolvemos esta instancia, obtenemos un árbol de expansión \( T^* \) de costo mínimo que cumple con las restricciones. Por lo que 
el árbol va a ser de la forma \[ v_1 - u_1 - u_2 - \ldots - u_{|V|-2} - v_2 \], donde \( u_i \in V \setminus \{v_1 , v_2\} \).

\begin{lemma}
    El árbol de expansión \( T^* \) obtenido en la instancia del DCMST corresponde a un ciclo hamiltoniano de costo mínimo en la instancia original del TSP.
\end{lemma}

\begin{proof}
    Dado el árbol \( T^* \), notese que si unimos nuevamente \(v_1\) y \(v_2\) como un solo vértice \(v\), obtenemos un ciclo hamiltoniano \(C^*\) en el grafo original \(G\) con costo igual al del árbol \(T^*\).
    Supongamos que existe un ciclo hamiltoniano \( C \) en \( G \) con costo menor que el costo de \( T^* \). Al dividir el vértice \(v\)
    en dos vértices \(v_1\) y \(v_2\), el ciclo \( C \) se transforma en un camino simple que cubre todos los vértices de la instancia del DCMST,
    obteniendose un árbol de expansión \(T'\) con costo menor que \( T^* \), lo cual es una contradicción ya que \( T^* \) es el de costo mínimo.

    Por reducción al absurdo, concluimos que \( C^* \) es un ciclo hamiltoniano de costo mínimo en la instancia original del TSP.
\end{proof}

Dado que todas las transformaciones realizadas son polinomiales en tiempo, tener una solución de DCMST en tiempo polinomial nos permite resolver cualquier instancia del TSP 
en tiempo polinomial. Por tanto DCMST es al menos tan difícil como TSP.

Por lo tanto, el problema DCMST es NP-Hard.
\end{proof}

\subsection{NP-Completitud del problema Degree-Constrained Spanning Tree}

Consideremos ahora la versión de decisión del problema, conocida como Degree-Constrained Spanning Tree (DCST), en la cual se pregunta si existe un árbol de expansión que satisfaga un conjunto dado de restricciones de grado, sin considerar una función de costo.

\begin{theorem}
El problema Degree-Constrained Spanning Tree (DCST) es NP-Completo.
\end{theorem}

\begin{proof}
En primer lugar, observemos que DCST pertenece a la clase NP. En efecto, dada una solución candidata \( T = (V, E') \), es posible verificar en tiempo polinomial que:
\begin{itemize}
    \item \( T \) es conexo y acíclico,
    \item \( |E'| = |V| - 1 \),
    \item \( \deg_T(v) \leq k(v) \) para todo \( v \in V \).
\end{itemize}

A continuación, demostramos que DCST es NP-Hard mediante una reducción polinomial desde el problema \textit{Hamiltonian Path}, el cual es NP-Completo.

Sea \( G = (V, E) \) una instancia arbitraria del problema Hamiltonian Path. Construimos una instancia del problema DCST sobre el mismo grafo \( G \), imponiendo una restricción de grado uniforme \( k(v) = 2 \) para todo vértice \( v \in V \).

Bajo esta restricción, cualquier árbol de expansión factible debe tener grado a lo sumo 2 en cada vértice. Como consecuencia, dicho árbol solo puede ser un camino simple que cubra todos los vértices del grafo, es decir, un camino hamiltoniano.

Por tanto, existe un árbol de expansión que satisface las restricciones de grado si y solo si existe un camino hamiltoniano en el grafo original. La reducción es claramente polinomial.

Dado que DCST es NP-Hard y pertenece a NP, se concluye que el problema DCST es NP-Completo.
\end{proof}

\section{Diseño de Soluciones Algorítmicas}
Se desarrollaron e implementaron cuatro enfoques principales. El código fuente completo de cada implementación se encuentra en el Apéndice A.

\subsection{Enumeración con Máscara de Bits para el DCMST}
Esta es una solución exacta para el problema DCMST basada en \textbf{enumeración exhaustiva mediante máscara de bits}. Esta solución está diseñada para instancias de tamaño pequeño, sirviendo como algoritmo de referencia y verificación de metaheurísticas.

El algoritmo explora todos los subconjuntos posibles de aristas que contienen exactamente $|V| - 1$ aristas y verifica cuáles inducen un árbol generador que cumple con la restricción de grado. Entre todas las soluciones factibles, selecciona la de costo mínimo. La implementación completa se encuentra en el Apéndice \ref{sec:code_bitmask}.

\subsubsection{Descripción del Algoritmo}
Sea $G = (V, E)$ un grafo completo, no dirigido y ponderado, con $|V| = n$ vértices y $|E| = m = \dfrac{n(n-1)}{2}$ aristas. El algoritmo procede de la siguiente manera:

\begin{enumerate}
    \item Se enumeran todas las aristas $E$ y se indexan de $0$ a $m-1$.
    \item Se recorre cada máscara de bits $mask \in \{0,1\}^m$.
    \item Solo se consideran las máscaras cuyo número de bits activos es exactamente $n-1$.
    \item Cada máscara define un subgrafo $G_{mask}$ compuesto por las aristas seleccionadas.
    \item Se verifica si:
    \begin{itemize}
        \item El subgrafo es conexo (usando Depth-First Search).
        \item El grado de cada vértice es a lo sumo $k$.
    \end{itemize}
    \item Si ambas condiciones se cumplen, el subgrafo es un árbol generador factible y se evalúa su costo.
    \item Se devuelve el mínimo costo entre todas las soluciones factibles.
\end{enumerate}

El uso de una máscara de bits permite representar subconjuntos de aristas de forma compacta y eficiente a nivel de implementación.

\subsubsection{Análisis de Correctitud}
Demostraremos que el algoritmo es correcto, es decir, que devuelve exactamente el costo del árbol generador mínimo con restricción de grado.

\begin{lemma}\label{lem:exhaustivity1}
    El algoritmo examina \textbf{todos} los subconjuntos de aristas de tamaño $n-1$.
\end{lemma}
\begin{proof}
    Cada máscara de bits $m$ representa un subconjunto único de aristas. Al iterar sobre todas las máscaras con $\text{popcount(mask)} = n-1$, se enumeran exactamente todos los subconjuntos de $E$ con $n-1$ aristas.
\end{proof}

\begin{lemma}\label{lem:factible_dcst1}
    Un subconjunto de aristas $E' \subseteq E$ con $|E'| = n-1$ es un árbol generador factible si y solo si:
    \begin{enumerate}
        \item El grafo inducido es conexo.
        \item Para todo vértice $v$, $\text{deg}(v) \le k$.
    \end{enumerate}
\end{lemma}
\begin{proof}
    Un grafo conexo con $n-1$ aristas es un árbol. La segunda condición garantiza la restricción de grado. Por lo tanto, ambas condiciones son necesarias y suficientes. 
\end{proof}

\begin{lemma}
    La función \texttt{check} devuelve verdadero si y solo si el subgrafo inducido por la máscara es un árbol generador factible.
\end{lemma}
\begin{proof}
    Inicialmente, verifica que ningún vértice tenga grado mayor que $k$. Luego, ejecuta un DFS desde el vértice $0$ y comprueba que todos los vértices son alcanzables, lo que implica conectividad. Por el Lema \ref{lem:factible_dcst1}, esto es equivalente a ser un DCST factible.
\end{proof}

\begin{theorem}
    El algoritmo devuelve el costo mínimo entre todos los árboles generadores que cumplen la restricción de grado.
\end{theorem}
\begin{proof}
    Por el Lema \ref{lem:exhaustivity1}, el algoritmo considera todas las soluciones candidatas. Por el Lema \ref{lem:factible_dcst1}, acepta exactamente las soluciones factibles. Finalmente, toma el mínimo costo entre ellas. Por lo tanto, el resultado es óptimo.
\end{proof}

\subsubsection{Análisis de Complejidad}
El número total de máscaras es $2^m$, pero las máscaras consideradas efectivamente son $\binom{m}{n-1}$ y por cada una de ellas se hace lo siguiente:
\begin{itemize}
    \item Construcción del subgrafo: $O(n)$.
    \item Verificación de grados: $O(n)$.
    \item DFS para conectividad: $O(n)$.
\end{itemize}
Por tanto, el costo por máscara es $O(n)$ y la complejidad total es: $O(2^m + \binom{m}{n-1} \cdot n)$.

\subsection{Enumeración Lexicográfica para el DCMST}
El algoritmo se basa en la enumeración exhaustiva de subconjuntos de aristas mediante una representación binaria y generación lexicográfica de combinaciones. Su aplicabilidad es sobre todo para instancias de tamaño reducido y es aplicable como algoritmo de referencia para la validación de metaheurísticas. (Ver Apéndice \ref{sec:code_comb}).

\subsubsection{Descripción del Algoritmo}
Sea $G = (V,E)$ un grafo completo con $|V| = n$ vértices y $|E| = m = \frac{n(n-1)}{2}$ aristas. El algoritmo procede como sigue:
\begin{enumerate} 
    \item Se indexan todas las aristas de $E$. 
    \item Se construye una cadena binaria \texttt{state} de longitud $m$ con exactamente $n-1$ bits activos. 
    \item Cada permutación lexicográfica de \texttt{state} representa un subconjunto distinto de $n-1$ aristas. 
    \item Para cada subconjunto: 
    \begin{itemize} 
        \item Se construye el subgrafo inducido. 
        \item Se verifica la restricción de grado. 
        \item Se comprueba conectividad mediante DFS. 
        \item Si es factible, se evalúa su costo. 
    \end{itemize} 
    \item Se devuelve el mínimo costo encontrado. 
\end{enumerate}

La generación de subconjuntos se realiza mediante la función \texttt{next\_permutation}, lo que garantiza que cada combinación se visita exactamente una vez.

\subsubsection{Análisis de Correctitud}
\begin{lemma}\label{lem:exhaustivity2}
    El algoritmo enumera todos los subconjuntos de aristas de tamaño $n-1$.
\end{lemma}
\begin{proof}
    La cadena binaria inicial contiene exactamente $n-1$ unos y $m-(n-1)$ ceros. El uso de \texttt{next\_permutation} genera todas las permutaciones distintas de dicha cadena, que corresponden biyectivamente a los subconjuntos de $E$ con $n-1$ elementos.
\end{proof}

\begin{lemma}\label{lem:factible_dcst2}
    Un subconjunto $E' \subseteq E$ con $|E'|=n-1$ es un árbol generador factible si y solo si: 
    \begin{enumerate} 
        \item El subgrafo inducido es conexo. 
        \item Para todo $v \in V$, $\deg(v) \leq k$. 
    \end{enumerate}
\end{lemma}
\begin{proof}
    Un grafo conexo con $n-1$ aristas es un árbol. La segunda condición garantiza la restricción de grado. Ambas son necesarias y suficientes.
\end{proof}

\begin{lemma}
    La función \texttt{check} devuelve verdadero si y solo si el subgrafo inducido por la máscara es un árbol generador factible.
\end{lemma}
\begin{proof}
    Inicialmente, verifica que ningún vértice tenga grado mayor que $k$. Luego, ejecuta un DFS desde el vértice $0$ y comprueba que todos los vértices son alcanzables, lo que implica conectividad. Por el Lema \ref{lem:factible_dcst2}, esto es equivalente a ser un DCST factible.
\end{proof}

\begin{theorem}
    El algoritmo devuelve el costo mínimo entre todos los árboles generadores que satisfacen la restricción de grado.    
\end{theorem}
\begin{proof}
    Por el Lema \ref{lem:exhaustivity2}, todas las soluciones candidatas son evaluadas. Por el Lema \ref{lem:factible_dcst2}, se aceptan exactamente las factibles. El algoritmo selecciona el mínimo costo entre ellas, lo que implica optimalidad.
\end{proof}

\subsubsection{Análisis de Complejidad}
El número de combinaciones evaluadas es: $\binom{m}{n-1}$ y para cada combinación:
\begin{itemize} 
    \item Construcción del subgrafo: $O(n)$. 
    \item Verificación de grados: $O(n)$. 
    \item DFS de conectividad: $O(n)$. 
\end{itemize}
Por lo tanto, la complejidad es $O(\binom{m}{n-1} \cdot n)$.

\subsection{Enumeración con Código de Gray}
A continuación se presenta dos algoritmos exactos para el DCMST basados en la enumeración exhaustiva de subconjuntos de aristas utilizando Código de Gray. El enfoque garantiza que subconjuntos consecutivos difieran en exactamente una arista, lo que permite una generación sistemática y eficiente del espacio de soluciones. Se propondrá una solución recursiva con podas.

\subsubsection{Marco Teórico: Código de Gray}
El código de Gray constituye una secuencia de representaciones binarias tal que dos códigos consecutivos difieren exactamente en un solo bit. Formalmente, el código Gray de un entero $n$ se define como:
$$G(n) = n \oplus (n>>1)$$



Una técnica para generar todas las combinaciones de tamaño $K$ consiste en generar la secuencia completa de códigos Gray para los enteros desde $0$ hasta $2^N - 1$ y filtrar únicamente aquellas máscaras que contienen exactamente $K$ bits activos. Un resultado fundamental es que, en la secuencia filtrada, dos combinaciones adyacentes (consideradas en sentido cíclico) difieren exactamente en dos bits, lo que equivale a eliminar un elemento y añadir otro.

Esta propiedad puede demostrarse por inducción utilizando la construcción recursiva del código Gray:
$$G(N) = 0G(N-1) \cup 1G(N-1)^R$$

\subsubsection{Descripción del Algoritmo Gray Iterativo}
Sea $G = (V,E)$ un grafo completo con $|V| = n$ vértices y $|E| = m = \frac{n(n-1)}{2}$ aristas. El algoritmo procede como sigue:

El algoritmo genera todas las máscaras de bits correspondientes a los códigos Gray de longitud $m$. Para cada máscara se verifica si contiene exactamente $n-1$ bits activos, lo que corresponde a un subconjunto candidato a árbol generador. (Ver Apéndice \ref{sec:code_gray_iter}).

Para cada subconjunto válido, se construye el grafo inducido y se comprueba: 
\begin{itemize} 
    \item Que el grado de cada vértice no exceda $k$; 
    \item Que el grafo sea conexo, mediante un DFS. 
\end{itemize}

El costo mínimo entre todas las configuraciones factibles es devuelto como solución.

\subsubsection{Análisis de Correctitud del Algoritmo Gray Iterativo}
\begin{lemma}\label{lem:exhaustivity3}
    El algoritmo enumera exhaustivamente todos los subconjuntos de aristas de tamaño $n-1$. 
\end{lemma}
\begin{proof} 
    La secuencia de códigos Gray recorre todas las máscaras binarias de longitud $m$. El filtrado por número de bits activos igual a $n-1$ garantiza que se consideran exactamente todos los subconjuntos de ese tamaño. 
\end{proof}

\begin{lemma}\label{lem:factible_dcst3}
    Todo subconjunto aceptado por el algoritmo que pasa las verificaciones corresponde a un árbol generador factible. 
\end{lemma}
\begin{proof} 
    Un subconjunto con $n-1$ aristas que induce un grafo conexo es, por definición, un árbol generador. La verificación adicional del grado asegura el cumplimiento de la restricción $\deg(v) \le k$ para todo vértice $v$. 
\end{proof}

\begin{theorem} 
    El algoritmo Gray iterativo devuelve un árbol generador mínimo que satisface la restricción de grado. 
\end{theorem}
\begin{proof} 
    Por el Lema \ref{lem:exhaustivity3} y por el Lema \ref{lem:factible_dcst3} el algoritmo evalúa exhaustivamente todas las soluciones factibles y selecciona aquella de menor costo, la solución devuelta es óptima.
\end{proof}

\subsubsection{Análisis de Complejidad del Algoritmo Gray Iterativo}
El algoritmo recorre $2^m$ máscaras, y analiza aquellas con exactamente $n-1$ aristas. Para cada una, la verificación de conectividad y grados requiere $O(n)$ tiempo. Por lo tanto, la complejidad temporal es: $O(2^m + \binom{m}{n-1} \cdot n)$.

\subsubsection{Descripción del Algoritmo Gray Recursivo}
El algoritmo Gray recursivo implementa directamente la relación:
$$G(N, K) = 0G(N-1, K) \cup 1G(N-1, K-1)^\text{R}$$
construyendo únicamente combinaciones válidas de $k = n-1$ aristas. (Ver Apéndice \ref{sec:code_gray_rec}).

Durante la recursión, se mantiene de forma incremental: 
\begin{itemize} 
    \item el costo acumulado; 
    \item la estructura de adyacencia; 
    \item las restricciones de grado. 
\end{itemize}

Las ramas que violan la restricción de grado se podan anticipadamente.

\subsubsection{Análisis de Correctitud del Algoritmo Gray Recursivo}
\begin{lemma}\label{lem:exhaustivity4}
    El algoritmo genera exactamente todas las combinaciones de $n-1$ aristas sin repetición. 
\end{lemma}
\begin{proof} 
    La recurrencia $G(N,K)$ genera todas las combinaciones binarias de longitud $N$ con exactamente $K$ bits activos, sin duplicados, por construcción inductiva. 
\end{proof}

\begin{lemma}\label{lem:factible_dcst4}
    Toda solución considerada por el algoritmo cumple la restricción de grado. 
\end{lemma}
\begin{proof} 
    Antes de continuar la recursión, el algoritmo verifica que el grado de los vértices involucrados no exceda $K$. Las ramas inválidas son descartadas. 
\end{proof}

\begin{theorem} 
    El algoritmo Gray recursivo produce una solución óptima del DCMST. 
\end{theorem}
\begin{proof} 
    Por el Lema \ref{lem:exhaustivity4} y por el Lema \ref{lem:factible_dcst4} el algoritmo explora exhaustivamente el espacio de soluciones factibles y conserva el mínimo costo encontrado, garantizando optimalidad.
\end{proof}

\section{Análisis Experimental}

\subsection{Implementación}

Con el objetivo de evaluar los algoritmos propuestos para la resolución del problema DCMST, se implementaron todas las soluciones descritas en la sección anterior 
utilizando el lenguaje de programación \texttt{C++}. La elección de este lenguaje se debe a su eficiencia, amplia disponibilidad de estructuras de datos de bajo 
nivel y la experiencia de los autores en el mismo, lo cual hace mas sencilla la implementación de algoritmos.

\subsection{Intancias de Prueba}

Las instancias de prueba utilizadas corresponden a grafos completos de distintos tamaños representados en matriz de adyacencia ponderada.

Cada instancia tiene el siguiente formato:
\begin{itemize}
    \item La primera línea contiene dos enteros: \( n \) (número de vértices) y \( k \) (restricción de grado para todo vértice).
    \item Las siguientes \( n \) líneas contienen \( n \) enteros cada una, representando la matriz de costos entre los vértices.
    \item Se garantiza que la matriz es simétrica y que los valores en la diagonal son cero.
\end{itemize}

\subsection{Experimentación}

Para cada instancia se evaluó el costo mínimo encontrado, así como el tiempo de ejecución de cada algoritmo, permitiendo comparar su desempeño relativo.

El propósito principal de este análisis experimental no es demostrar escalabilidad, sino:
\begin{itemize}
    \item Validar la correctitud de las implementaciones.
    \item Comparar el impacto de distintas estrategias sobre el tiempo de ejecución.
\end{itemize}

\subsection{Resultados}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{../src/resultados.png}
    \caption{Resultados experimentales: comparación de costos y tiempos entre los algoritmos implementados.}
    \label{fig:resultados}
\end{figure}

\section{Conclusiones}
En este trabajo se detalló el análisis y solución del problema DCMST. Se demostró su complejidad NP-Hard y se presentaron cuatro variantes algorítmicas exactas para su resolución.

\newpage
\appendix
\section{Apéndice: Implementaciones en C++}

A continuación se presentan las implementaciones completas utilizadas en el estudio.

\subsection{Solución 1: Fuerza Bruta con Máscara de Bits} \label{sec:code_bitmask}
\lstinputlisting[
    language=C++
]{../src/solutions/bitmask.cpp}


\subsection{Solución 2: Generación Combinatoria Lexicográfica} \label{sec:code_comb}
\lstinputlisting[
    language=C++
]{../src/solutions/comb.cpp}

\subsection{Solución 3: Código de Gray Iterativo} \label{sec:code_gray_iter}
\lstinputlisting[
    language=C++
]{../src/solutions/gray_iterative.cpp}


\subsection{Solución 4: Código de Gray Recursivo con Poda} \label{sec:code_gray_rec}
\lstinputlisting[
    language=C++
]{../src/solutions/gray_recursive.cpp}

\begin{thebibliography}{9}
\bibitem{clrs} 
Cormen, T. H., Leiserson, C. E., Rivest, R. L., \& Stein, C. (2009). 
\textit{Introduction to Algorithms} (3rd ed., Chapter 34). 
MIT Press.
\end{thebibliography}

\end{document}