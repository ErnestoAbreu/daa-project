\documentclass[twoside,10pt]{article}

% --- Paquetes de Idioma y Codificación ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish,es-tabla]{babel} 

% --- Paquetes Matemáticos y Teoremas ---
\usepackage{amsmath, amssymb, amsthm, amsfonts}
\usepackage{mathtools}

% --- Paquetes de Diseño, Gráficos y Tablas ---
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{booktabs} 
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{authblk} 
\usepackage{multirow}

% --- Paquetes para Código Fuente ---
\usepackage{listings}
\usepackage{xcolor}

% --- Configuración de Hipervínculos ---
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    citecolor=red,
    urlcolor=blue
}

% --- Configuración de Márgenes ---
\geometry{top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm}

% --- Definiciones Matemáticas ---
\DeclareMathOperator*{\argmin}{arg\,min}
\newtheorem{definition}{Definición}[section]
\newtheorem{theorem}{Teorema}[section]
\newtheorem{lemma}[theorem]{Lema}

% --- Estilo de Código C++ ---
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.96,0.96,0.96}

\lstdefinestyle{cppstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C++
}
\lstset{style=cppstyle}

% --- Título y Autores ---
\title{\textbf{Optimización de Red de Fibra Óptica \\ (Degree-Constrained Minimum Spanning Tree)}}

\author{Ernesto Abreu Peraza}
\author{Eduardo Brito Labrada}
\affil{Diseño y Análisis de Algoritmos - Universidad de La Habana}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
\noindent Este informe detalla el análisis e implementa soluciones al conocido problema NP-Hard Degree Constrained Minimum Spanning Tree para la infraestructura de red de la Universidad de La Habana. 
Se presenta la formalización matemática, la demostración de su complejidad computacional y una comparativa experimental entre diferentes algoritmos.
\end{abstract}

\newpage
\tableofcontents
\newpage


\section{Introducción}

El diseño eficiente de redes de comunicación constituye un problema fundamental en múltiples dominios de la ingeniería y las ciencias de la computación, particularmente en el contexto de infraestructuras físicas como redes de fibra óptica. En estos escenarios, no solo resulta relevante minimizar el costo total de interconexión, sino también respetar restricciones técnicas impuestas por el equipamiento disponible, tales como el número máximo de conexiones que puede soportar cada nodo de la red.

El problema del Árbol de Expansión Mínimo con Restricciones de Grado (\textit{Degree-Constrained Minimum Spanning Tree}, DCMST) surge de manera natural al modelar este tipo de situaciones. A diferencia del problema clásico del Árbol de Expansión Mínimo (MST), el DCMST impone cotas superiores al grado de cada vértice, lo cual incrementa significativamente su complejidad computacional. De hecho, el DCMST es un problema NP-Hard, lo que implica que, salvo que \( \text{P} = \text{NP} \), no existen algoritmos que lo resuelvan de manera eficiente para grandes instancias.

Motivado por el problema definido en este \href{https://github.com/ErnestoAbreu/daa-project/blob/main/docs/problem.md}{documento}, se realiza una formalización matemática rigurosa del problema, se analizan y se demuestra su complejidad computacional.

Adicionalmente, se diseñan e implementan varios algoritmos y se presenta un análisis experimental que permite comparar el comportamiento de las distintas estrategias implementadas.


\section{Formalización del Problema}
Partiendo de la necesidad de interconectar los edificios de la universidad minimizando costos y respetando la capacidad 
de puertos de ETECSA, definimos el modelo matemático.

\subsection{Modelo Matemático}
Sea $G = (V, E)$ un grafo conexo y no dirigido, donde:
\begin{itemize}
    \item $V$ es el conjunto de edificios.
    \item $E$ es el conjunto de posibles conexiones de fibra.
    \item $w: E \to \mathbb{R}^+$ es una función de costo.
    \item $k: V \to \mathbb{N}$ es la capacidad de puertos por edificio.
\end{itemize}

El problema consiste en encontrar un subgrafo $T = (V, E')$ tal que:
\begin{equation}
    T^* = \argmin_{T \in \mathcal{T}} \sum_{e \in E'} w(e)
\end{equation}
Sujeto a:
\begin{enumerate}
    \item $T$ es un árbol de expansión de $G$.
    \item $\forall v \in V, \text{deg}_T(v) \leq k(v)$.
\end{enumerate}

Este problema es conocido como \textit{Degree-Constrained Minimum Spanning Tree} (DCMST).

\subsection{Variantes del Problema}

Analicemos algunas variantes, las cuales surgen a partir de diferentes supuestos sobre la estructura del grafo y las 
restricciones de grado.

\subsubsection{DCMST en grafos completos}

Una variante relevante del DCMST es aquella en la que el grafo se asume completo. Formalmente, se considera un grafo no dirigido
\[
G = (V, E),
\]
donde
\[
E = \{ \{u,v\} \mid u,v \in V,\; u \neq v \}.
\]

Este modelo se ajusta bien al problema original, dado que de no existir una conexión original entre dos vértices 
(porque sea imposible conectar dos edificios), puedes asignar un costo \textit{infinito} a dicha arista, asegurando 
que no será seleccionada en la solución óptima. De ser seleccionada representaría que no se encontró solución factible.


Analizando la complejidad temporal, el carácter completo del grafo incrementa significativamente el número de aristas al peor caso,
\[
|E| = \frac{|V|(|V|-1)}{2} = O(|V|^2).
\]

\subsubsection{DCMST con restricción de grado uniforme}

Otra variante ampliamente estudiada es aquella en la que el límite de grado es uniforme para todos los vértices del grafo. 
En este caso, se fija un valor entero constante \( K \geq 2 \) tal que
\[
\deg_T(v) \leq K \quad \forall v \in V,
\]
donde \( \deg_T(v) \) denota el grado del vértice \( v \) en el árbol generador \( T \).

Esta formulación es adecuada en el caso en que el equipamiento de red sea el mismo para todos los edificios.

Además si tomamos \( K = \min_{v \in V} k(v) \), una solución optima de esta instancia es una solución factible, 
aunque no necesariamente óptima, para la instancia del problema original.

\subsubsection{Degree-Constrained Spanning Tree (DCST)}

Una variante adicional es el problema Degree-Constrained Spanning Tree. En esta versión, el objetivo no consiste en 
minimizar el peso total del árbol, sino únicamente en determinar la existencia de un árbol generador que satisfaga las 
restricciones estructurales.

Este problema puede ser formulado como un problema de decisión o factibilidad. A pesar de la ausencia de una función 
objetivo de optimización, la determinación de la existencia de una solución válida sigue siendo computacionalmente 
difícil en el caso general. Esta variante resulta de interés teórico y se emplea frecuentemente como base para el 
estudio de la complejidad del DCMST y el diseño de algoritmos exactos y aproximados.

\vspace{1em}

En la siguiente sección, se analizará la complejidad computacional del DCMST y sus variantes. En la experimentación nos 
enfocaremos principalmente analizando DCMST en grafos completos con restricción de grado uniforme por los beneficios 
planteados anteriormente.


\section{Análisis de Complejidad Computacional}

\subsection{Demostración de NP-Hardness del problema DCMST}

Para analizar la complejidad computacional del problema, demostramos que dicho problema es NP-Hard mediante una reducción 
polinomial desde el problema del Viajante de Comercio (\textit{Traveling Salesman Problem}, TSP), uno de los problemas 
clásicos NP-Hard.

\begin{theorem}
El problema Degree-Constrained Minimum Spanning Tree es NP-Hard.
\end{theorem}

\begin{proof}
Consideremos una instancia arbitraria del problema del Viajante. Dicha instancia está definida por un grafo completo no dirigido
\[
G = (V, E),
\]
junto con una función de costos \( w: E \rightarrow \mathbb{R}^+ \). El objetivo del TSP es encontrar un ciclo simple de costo 
mínimo que visite exactamente una vez cada vértice. Un ciclo simple que cubre todos los vértices es conocido como ciclo hamiltoniano.

A partir de esta instancia, construimos una instancia del problema DCMST de la siguiente manera:
\begin{itemize}
    \item Obtenemos el mismo grafo \( G = (V, E) \) y la misma función de costos \( w \).
    \item Sea \(v\) un vértice cualquiera de \(G\)
    \item Dividimos \(v\) en dos vértices \(v_1\) y \(v_2\), tal que \(k(v_1) = 1 \) y \(k(v_2) = 1\).
    \item Asignamos restricciones de grado \( k(u) = 2 \) para todo \( u \in V \setminus \{v_1 , v_2\} \).
\end{itemize}

Observemos que, bajo esta restricción, cualquier árbol de expansión válido \( T \) debe satisfacer
\[
\deg_T(v) \leq 2 \quad \forall v \in V.
\]
Un árbol de expansión con grado máximo 2 en todos los vértices es necesariamente un camino simple que cubre todos los vértices del grafo.
En todo camino simple, los vértices extremos tienen grado 1 y los vértices intermedios tienen grado 2.

Si resolvemos esta instancia, obtenemos un árbol de expansión \( T^* \) de costo mínimo que cumple con las restricciones. Por lo que 
el árbol va a ser de la forma \[ v_1 - u_1 - u_2 - \ldots - u_{|V|-2} - v_2 \], donde \( u_i \in V \setminus \{v_1 , v_2\} \).

\begin{lemma}
    El árbol de expansión \( T^* \) obtenido en la instancia del DCMST corresponde a un ciclo hamiltoniano de costo mínimo en la instancia original del TSP.
\end{lemma}

\begin{proof}
    Dado el árbol \( T^* \), notese que si unimos nuevamente \(v_1\) y \(v_2\) como un solo vértice \(v\), obtenemos un ciclo hamiltoniano \(C^*\) en el grafo original \(G\) con costo igual al del árbol \(T^*\).
    Supongamos que existe un ciclo hamiltoniano \( C \) en \( G \) con costo menor que el costo de \( T^* \). Al dividir el vértice \(v\)
    en dos vértices \(v_1\) y \(v_2\), el ciclo \( C \) se transforma en un camino simple que cubre todos los vértices de la instancia del DCMST,
    obteniendose un árbol de expansión \(T'\) con costo menor que \( T^* \), lo cual es una contradicción ya que \( T^* \) es el de costo mínimo.

    Por reducción al absurdo, concluimos que \( C^* \) es un ciclo hamiltoniano de costo mínimo en la instancia original del TSP.
\end{proof}

Dado que todas las transformaciones realizadas son polinomiales en tiempo, tener una solución de DCMST en tiempo polinomial nos permite resolver cualquier instancia del TSP 
en tiempo polinomial. Por tanto DCMST es al menos tan difícil como TSP.

Por lo tanto, el problema DCMST es NP-Hard.
\end{proof}

\subsection{NP-Completitud del problema Degree-Constrained Spanning Tree}

Consideremos ahora la versión de decisión del problema, conocida como Degree-Constrained Spanning Tree (DCST), en la cual se pregunta si existe un árbol de expansión que satisfaga un conjunto dado de restricciones de grado, sin considerar una función de costo.

\begin{theorem}
El problema Degree-Constrained Spanning Tree (DCST) es NP-Completo.
\end{theorem}

\begin{proof}
En primer lugar, observemos que DCST pertenece a la clase NP. En efecto, dada una solución candidata \( T = (V, E') \), es posible verificar en tiempo polinomial que:
\begin{itemize}
    \item \( T \) es conexo y acíclico,
    \item \( |E'| = |V| - 1 \),
    \item \( \deg_T(v) \leq k(v) \) para todo \( v \in V \).
\end{itemize}

A continuación, demostramos que DCST es NP-Hard mediante una reducción polinomial desde el problema \textit{Hamiltonian Path}, el cual es NP-Completo.

Sea \( G = (V, E) \) una instancia arbitraria del problema Hamiltonian Path. Construimos una instancia del problema DCST sobre el mismo grafo \( G \), imponiendo una restricción de grado uniforme \( k(v) = 2 \) para todo vértice \( v \in V \).

Bajo esta restricción, cualquier árbol de expansión factible debe tener grado a lo sumo 2 en cada vértice. Como consecuencia, dicho árbol solo puede ser un camino simple que cubra todos los vértices del grafo, es decir, un camino hamiltoniano.

Por tanto, existe un árbol de expansión que satisface las restricciones de grado si y solo si existe un camino hamiltoniano en el grafo original. La reducción es claramente polinomial.

Dado que DCST es NP-Hard y pertenece a NP, se concluye que el problema DCST es NP-Completo.
\end{proof}

\section{Diseño de Soluciones Algorítmicas}
Se desarrollaron e implementaron cuatro enfoques principales. El código fuente completo de cada implementación se encuentra en el Apéndice A.

\subsection{Enumeración con Máscara de Bits para el DCMST}
Esta es una solución exacta para el problema DCMST basada en \textbf{enumeración exhaustiva mediante máscara de bits}. Esta solución está diseñada para instancias de tamaño pequeño, sirviendo como algoritmo de referencia y verificación de metaheurísticas.

El algoritmo explora todos los subconjuntos posibles de aristas que contienen exactamente $|V| - 1$ aristas y verifica cuáles inducen un árbol generador que cumple con la restricción de grado. Entre todas las soluciones factibles, selecciona la de costo mínimo. La implementación completa se encuentra en el Apéndice \ref{sec:code_bitmask}.

\subsubsection{Descripción del Algoritmo}
Sea $G = (V, E)$ un grafo completo, no dirigido y ponderado, con $|V| = n$ vértices y $|E| = m = \dfrac{n(n-1)}{2}$ aristas. El algoritmo procede de la siguiente manera:

\begin{enumerate}
    \item Se enumeran todas las aristas $E$ y se indexan de $0$ a $m-1$.
    \item Se recorre cada máscara de bits $mask \in \{0,1\}^m$.
    \item Solo se consideran las máscaras cuyo número de bits activos es exactamente $n-1$.
    \item Cada máscara define un subgrafo $G_{mask}$ compuesto por las aristas seleccionadas.
    \item Se verifica si:
    \begin{itemize}
        \item El subgrafo es conexo (usando Depth-First Search).
        \item El grado de cada vértice es a lo sumo $k$.
    \end{itemize}
    \item Si ambas condiciones se cumplen, el subgrafo es un árbol generador factible y se evalúa su costo.
    \item Se devuelve el mínimo costo entre todas las soluciones factibles.
\end{enumerate}

El uso de una máscara de bits permite representar subconjuntos de aristas de forma compacta y eficiente a nivel de implementación.

\subsubsection{Análisis de Correctitud}
Demostraremos que el algoritmo es correcto, es decir, que devuelve exactamente el costo del árbol generador mínimo con restricción de grado.

\begin{lemma}\label{lem:exhaustivity1}
    El algoritmo examina \textbf{todos} los subconjuntos de aristas de tamaño $n-1$.
\end{lemma}
\begin{proof}
    Cada máscara de bits $m$ representa un subconjunto único de aristas. Al iterar sobre todas las máscaras con $\text{popcount(mask)} = n-1$, se enumeran exactamente todos los subconjuntos de $E$ con $n-1$ aristas.
\end{proof}

\begin{lemma}\label{lem:factible_dcst1}
    Un subconjunto de aristas $E' \subseteq E$ con $|E'| = n-1$ es un árbol generador factible si y solo si:
    \begin{enumerate}
        \item El grafo inducido es conexo.
        \item Para todo vértice $v$, $\text{deg}(v) \le k$.
    \end{enumerate}
\end{lemma}
\begin{proof}
    Un grafo conexo con $n-1$ aristas es un árbol. La segunda condición garantiza la restricción de grado. Por lo tanto, ambas condiciones son necesarias y suficientes. 
\end{proof}

\begin{lemma}
    La función \texttt{check} devuelve verdadero si y solo si el subgrafo inducido por la máscara es un árbol generador factible.
\end{lemma}
\begin{proof}
    Inicialmente, verifica que ningún vértice tenga grado mayor que $k$. Luego, ejecuta un DFS desde el vértice $0$ y comprueba que todos los vértices son alcanzables, lo que implica conectividad. Por el Lema \ref{lem:factible_dcst1}, esto es equivalente a ser un DCST factible.
\end{proof}

\begin{theorem}
    El algoritmo devuelve el costo mínimo entre todos los árboles generadores que cumplen la restricción de grado.
\end{theorem}
\begin{proof}
    Por el Lema \ref{lem:exhaustivity1}, el algoritmo considera todas las soluciones candidatas. Por el Lema \ref{lem:factible_dcst1}, acepta exactamente las soluciones factibles. Finalmente, toma el mínimo costo entre ellas. Por lo tanto, el resultado es óptimo.
\end{proof}

\subsubsection{Análisis de Complejidad}
El número total de máscaras es $2^m$, pero las máscaras consideradas efectivamente son $\binom{m}{n-1}$ y por cada una de ellas se hace lo siguiente:
\begin{itemize}
    \item Construcción del subgrafo: $O(n)$.
    \item Verificación de grados: $O(n)$.
    \item DFS para conectividad: $O(n)$.
\end{itemize}
Por tanto, el costo por máscara es $O(n)$ y la complejidad total es: $O(2^m + \binom{m}{n-1} \cdot n)$.

\subsection{Enumeración Lexicográfica para el DCMST}
El algoritmo se basa en la enumeración exhaustiva de subconjuntos de aristas mediante una representación binaria y generación lexicográfica de combinaciones. Su aplicabilidad es sobre todo para instancias de tamaño reducido y es aplicable como algoritmo de referencia para la validación de metaheurísticas. (Ver Apéndice \ref{sec:code_comb}).

\subsubsection{Descripción del Algoritmo}
Sea $G = (V,E)$ un grafo completo con $|V| = n$ vértices y $|E| = m = \frac{n(n-1)}{2}$ aristas. El algoritmo procede como sigue:
\begin{enumerate} 
    \item Se indexan todas las aristas de $E$. 
    \item Se construye una cadena binaria \texttt{state} de longitud $m$ con exactamente $n-1$ bits activos. 
    \item Cada permutación lexicográfica de \texttt{state} representa un subconjunto distinto de $n-1$ aristas. 
    \item Para cada subconjunto: 
    \begin{itemize} 
        \item Se construye el subgrafo inducido. 
        \item Se verifica la restricción de grado. 
        \item Se comprueba conectividad mediante DFS. 
        \item Si es factible, se evalúa su costo. 
    \end{itemize} 
    \item Se devuelve el mínimo costo encontrado. 
\end{enumerate}

La generación de subconjuntos se realiza mediante la función \texttt{next\_permutation}, lo que garantiza que cada combinación se visita exactamente una vez.

\subsubsection{Análisis de Correctitud}
\begin{lemma}\label{lem:exhaustivity2}
    El algoritmo enumera todos los subconjuntos de aristas de tamaño $n-1$.
\end{lemma}
\begin{proof}
    La cadena binaria inicial contiene exactamente $n-1$ unos y $m-(n-1)$ ceros. El uso de \texttt{next\_permutation} genera todas las permutaciones distintas de dicha cadena, que corresponden biyectivamente a los subconjuntos de $E$ con $n-1$ elementos.
\end{proof}

\begin{lemma}\label{lem:factible_dcst2}
    Un subconjunto $E' \subseteq E$ con $|E'|=n-1$ es un árbol generador factible si y solo si: 
    \begin{enumerate} 
        \item El subgrafo inducido es conexo. 
        \item Para todo $v \in V$, $\deg(v) \leq k$. 
    \end{enumerate}
\end{lemma}
\begin{proof}
    Un grafo conexo con $n-1$ aristas es un árbol. La segunda condición garantiza la restricción de grado. Ambas son necesarias y suficientes.
\end{proof}

\begin{lemma}
    La función \texttt{check} devuelve verdadero si y solo si el subgrafo inducido por la máscara es un árbol generador factible.
\end{lemma}
\begin{proof}
    Inicialmente, verifica que ningún vértice tenga grado mayor que $k$. Luego, ejecuta un DFS desde el vértice $0$ y comprueba que todos los vértices son alcanzables, lo que implica conectividad. Por el Lema \ref{lem:factible_dcst2}, esto es equivalente a ser un DCST factible.
\end{proof}

\begin{theorem}
    El algoritmo devuelve el costo mínimo entre todos los árboles generadores que satisfacen la restricción de grado.    
\end{theorem}
\begin{proof}
    Por el Lema \ref{lem:exhaustivity2}, todas las soluciones candidatas son evaluadas. Por el Lema \ref{lem:factible_dcst2}, se aceptan exactamente las factibles. El algoritmo selecciona el mínimo costo entre ellas, lo que implica optimalidad.
\end{proof}

\subsubsection{Análisis de Complejidad}
El número de combinaciones evaluadas es: $\binom{m}{n-1}$ y para cada combinación:
\begin{itemize} 
    \item Construcción del subgrafo: $O(n)$. 
    \item Verificación de grados: $O(n)$. 
    \item DFS de conectividad: $O(n)$. 
\end{itemize}
Por lo tanto, la complejidad es $O(\binom{m}{n-1} \cdot n)$.

\subsection{Enumeración con Código de Gray}
A continuación se presenta un algoritmo exacto para el DCMST basados en la enumeración exhaustiva de subconjuntos de aristas utilizando Código de Gray. El enfoque garantiza que subconjuntos consecutivos difieran en exactamente una arista, lo que permite una generación sistemática y eficiente del espacio de soluciones. Se propondrá una solución recursiva con podas.

\subsubsection{Marco Teórico: Código de Gray}
El código de Gray constituye una secuencia de representaciones binarias tal que dos códigos consecutivos difieren exactamente en un solo bit. Formalmente, el código Gray de un entero $n$ se define como:
$$G(n) = n \oplus (n>>1)$$

Una técnica para generar todas las combinaciones de tamaño $K$ consiste en generar la secuencia completa de códigos Gray para los enteros desde $0$ hasta $2^N - 1$ y filtrar únicamente aquellas máscaras que contienen exactamente $K$ bits activos. Un resultado fundamental es que, en la secuencia filtrada, dos combinaciones adyacentes (consideradas en sentido cíclico) difieren exactamente en dos bits, lo que equivale a eliminar un elemento y añadir otro.

Esta propiedad puede demostrarse por inducción utilizando la construcción recursiva del código Gray:
$$G(N) = 0G(N-1) \cup 1G(N-1)^R$$

\subsubsection{Descripción del Algoritmo Gray Recursivo}
El algoritmo Gray recursivo implementa directamente la relación:
$$G(N, K) = 0G(N-1, K) \cup 1G(N-1, K-1)^\text{R}$$
construyendo únicamente combinaciones válidas de $k = n-1$ aristas. (Ver Apéndice \ref{sec:code_gray_rec}).

Durante la recursión, se mantiene de forma incremental: 
\begin{itemize} 
    \item el costo acumulado; 
    \item la estructura de adyacencia; 
    \item las restricciones de grado. 
\end{itemize}

Las ramas que violan la restricción de grado se podan anticipadamente.

\subsubsection{Análisis de Correctitud del Algoritmo Gray Recursivo}
\begin{lemma}\label{lem:exhaustivity4}
    El algoritmo genera exactamente todas las combinaciones de $n-1$ aristas sin repetición. 
\end{lemma}
\begin{proof} 
    Procedemos por inducción fuerte sobre $N$, la longitud de la cadena binaria (número total de aristas disponibles).

    \textbf{Caso base:} Para $N=0$ , $G(0,0)=\{\epsilon\}$, que representa la única combinación de $0$ aristas. Para $K>0$, $G(0,K)=\emptyset$, correctamente generando ninguna combinación.

    \textbf{Hipótesis inductiva:} Supongamos que para todo $n' < N$, $G(n',K)$  genera exhaustiva y sin repeticiones todas las combinaciones binarias de longitud $n'$ con exactamente $K$ bits activos.

    \textbf{Paso inductivo:} Para $G(N,K)$, consideremos cualquier combinación válida $s$ de longitud $N$ con $K$ bits $1$. Examinamos su primer bit:

    \begin{itemize}
        \item Si $s_1=0$, entonces el sufijo $s_{2..N}$ es una combinación válida de longitud $N-1$ con $K$ bits $1$. Por hipótesis, aparece en $G(N'1,K)$, luego $0s_{2..N}$ aparece en $0G(N-1,K)$.
        \item Si $s_1=1$, entonces $s_{2..N}$ tiene $K-1$ bits $1$. Por hipótesis, aparece en $G(N-1,K-1)$, luego $1s_{2..N}$ aparece en $1G(N-1,K-1)^R$.
    \end{itemize}

    La unión disjunta $\cup$ de ambos conjuntos cubre todas las posibilidades sin superposición, pues difieren en su primer bit.

    Por tanto, $G(N,K)$ genera exactamente todas las combinaciones buscadas, sin duplicados.
\end{proof}

\begin{lemma}\label{lem:factible_dcst4}
    Toda solución considerada por el algoritmo cumple la restricción de grado. 
\end{lemma}
\begin{proof} 
    Antes de continuar la recursión, el algoritmo verifica que el grado de los vértices involucrados no exceda $K$. Las ramas inválidas son descartadas. 
\end{proof}

\begin{theorem} 
    El algoritmo Gray recursivo produce una solución óptima del DCMST. 
\end{theorem}
\begin{proof} 
    Por el Lema \ref{lem:exhaustivity4} y por el Lema \ref{lem:factible_dcst4} el algoritmo explora exhaustivamente el espacio de soluciones factibles y conserva el mínimo costo encontrado, garantizando optimalidad.
\end{proof}

\section{Diseño de metaheurísticas para resolver el DCMST}

\subsection{Método Primal Aleatorizado (RPM)}

El problema del Árbol de Expansión Mínima con Restricción de Grado (DCMST) busca encontrar un subgrafo $T$ de un grafo ponderado $G=(V, E)$ tal que $T$ sea un árbol que cubra todos los vértices en $V$, minimice la suma de los pesos de las aristas y satisfaga la restricción de que ningún vértice tenga un grado mayor a $d$.

Matemáticamente, buscamos minimizar:
\begin{equation}
Z(x) = \sum_{e \in E} w_e x_e
\end{equation}
Sujeto a:
\begin{equation}
\sum_{e \in \delta(v)} x_e \leq d, \quad \forall v \in V
\end{equation}
donde $x_e \in \{0, 1\}$ indica si la arista $e$ está en el árbol, y $\delta(v)$ es el conjunto de aristas incidentes en $v$. A diferencia del MST clásico, el DCMST es un problema NP-hard para $2 \leq d < |V|-1$.

La solución implementada utiliza el \textit{Randomised Primal Method} (RPM). Este enfoque híbrido combina la eficiencia constructiva del algoritmo de Prim con la capacidad de exploración de un Algoritmo Genético (AG).

\subsubsection{Codificación del Cromosoma}

En lugar de codificar aristas directamente (lo cual generaría muchas soluciones infactibles), el RPM utiliza una codificación indirecta. Un cromosoma es una matriz $C$ de dimensiones $n \times (d-1)$, donde $n$ es el número de nodos.

El alelo $C[i][k]$ representa un índice de preferencia. Específicamente, indica que cuando el algoritmo de construcción está considerando el nodo $i$ y este tiene actualmente un grado $k$, debe seleccionar la $C[i][k]$-ésima mejor arista disponible incidente a $i$.

\subsubsection{Decodificación (Algoritmo de Prim Modificado)}

El decodificador construye el árbol iterativamente:
\begin{enumerate}
    \item Se inicia con un vértice arbitrario en el árbol $S$.
    \item En cada paso, se identifican todas las aristas válidas que conectan un nodo $u \in S$ con un nodo $v \notin S$, siempre que $grado(u) < d$.
    \item Para cada nodo $u \in S$, en lugar de elegir obligatoriamente la arista de menor peso (como en Prim clásico), se consulta el cromosoma. Se selecciona la arista en la posición $C[u][grado\_actual(u)]$ de su lista de adyacencia ordenada.
    \item De este subconjunto de aristas candidatas seleccionadas por el cromosoma, se elige la de menor peso global para añadirla al árbol.
\end{enumerate}

\subsubsection{Operadores Genéticos e Inicialización}
\begin{itemize}
    \item \textbf{Inicialización Sesgada:} Para asegurar que la búsqueda comience en regiones prometedoras, los alelos no se generan uniformemente. Se utiliza una distribución geométrica (o exponencial negativa discreta) para favorecer valores bajos $(0, 1)$. Esto significa que el algoritmo tiende a comportarse como el algoritmo de Prim (codicioso) con pequeñas perturbaciones estocásticas.
    \item \textbf{Cruce:} Se implementa un cruce uniforme (\textit{Uniform Crossover}), donde cada gen del hijo se toma de uno de los padres con probabilidad 0.5.
    \item \textbf{Mutación:} Se aplica una mutación puntual con baja probabilidad, reasignando el valor del gen utilizando la misma distribución geométrica sesgada de la inicialización.
\end{itemize}

\subsubsection{Manejo de Soluciones Inválidas}
Dado que las restricciones de grado pueden, en ciertas topologías, llevar a callejones sin salida donde no es posible conectar más nodos sin violar restricciones, el decodificador incluye un mecanismo de seguridad. Si el árbol no logra conectar los $n$ nodos, la solución se marca como \texttt{valid = false} y se le asigna un costo infinito, siendo descartada por el proceso de selección del AG.

\subsection{Colonia de Hormigas (ACS)}

La implementación sigue el paradigma del \textit{Ant Colony System} (ACS). El algoritmo construye soluciones iterativamente mediante agentes (hormigas) que recorren el grafo tomando decisiones probabilísticas basadas en dos parámetros: la feromona ($\tau$) y la heurística ($\eta$).

\subsubsection{Modelo de Decisión}

Para una hormiga situada en el proceso de construcción, la elección de la siguiente arista $(u, v)$ para añadir al árbol se basa en la ``atractividad'' de la arista, definida como:

\begin{equation}
    Attr_{uv} = [\tau_{uv}]^\alpha \cdot [\eta_{uv}]^\beta
\end{equation}

Donde:
\begin{itemize}
    \item $\tau_{uv}$: Nivel de feromona en la arista $(u, v)$, representando la experiencia acumulada de la colonia.
    \item $\eta_{uv}$: Información heurística, definida inversamente proporcional al peso de la arista ($w_{uv}$):
    \begin{equation}
        \eta_{uv} = \frac{1}{w_{uv} + \epsilon}
    \end{equation}
    \item $\alpha, \beta$: Parámetros que controlan la influencia relativa de la feromona y la heurística.
\end{itemize}

\subsubsection{Regla de Transición Pseudo-Aleatoria}

El algoritmo implementa una regla de decisión híbrida controlada por el parámetro $q_0$ (probabilidad de explotación):

Si se genera un número aleatorio $q \in [0, 1]$ tal que $q \leq q_0$, la hormiga elige determinísticamente la mejor arista:
\begin{equation}
    (u, v)^* = \arg \max_{(u,v) \in \mathcal{C}} \{ Attr_{uv} \}
\end{equation}

En caso contrario ($q > q_0$), la hormiga realiza una selección probabilística (exploración) tipo ruleta, donde la probabilidad $P_{uv}$ de elegir la arista $(u, v)$ es:
\begin{equation}
    P_{uv} = \frac{Attr_{uv}}{\sum_{(i,j) \in \mathcal{C}} Attr_{ij}}
\end{equation}

Donde $\mathcal{C}$ es el conjunto de aristas candidatas factibles (aquellas que no cierran ciclos y cumplen la restricción de grado $K$).

\subsubsection{Actualización de Feromonas}

La actualización de feromonas sigue un enfoque elitista para acelerar la convergencia.
\begin{itemize}
\item \textbf{Evaporación:} Al final de cada iteración global, la feromona en todas las aristas se evapora para evitar óptimos locales:
\begin{equation}
    \tau_{uv} \leftarrow \tau_{uv} \cdot (1 - \rho)
\end{equation}
\item \textbf{Depósito de Feromona:} Se realiza un refuerzo basado en las mejores soluciones encontradas:
\begin{enumerate}
    \item \textbf{Mejor Local:} La mejor hormiga de la iteración actual deposita feromona.
    \item \textbf{Mejor Global:} La mejor solución encontrada desde el inicio del algoritmo deposita un refuerzo adicional.
\end{enumerate}
El incremento de feromona $\Delta \tau$ es inversamente proporcional al costo total del árbol ($C_{best}$):
\begin{equation}
    \tau_{uv} \leftarrow \tau_{uv} + \frac{\text{Constante}}{C_{best}}
\end{equation}
\end{itemize}


\section{Análisis Experimental}

\subsection{Implementación}

Con el objetivo de evaluar los algoritmos propuestos para la resolución del problema DCMST, se implementaron todas las soluciones descritas en la sección anterior 
utilizando el lenguaje de programación \texttt{C++}. La elección de este lenguaje se debe a su eficiencia, amplia disponibilidad de estructuras de datos de bajo 
nivel y la experiencia de los autores en el mismo, lo cual hace mas sencilla la implementación de algoritmos.

\subsection{Intancias de Prueba}

La evaluación se hará por grupos. Cada grupo contiene un conjunto de instancias de prueba con un valor de $100$ puntos cada uno. La puntuación para un grupo será la suma de los puntos obtenidos en cada instancia de ese grupo.

Los puntos serán otorgados dependiendo de qué tan cerca esté la solución del mínimo costo sin tener en cuenta la restricción de $k$ o de una solución exacta encontrada previamente para esa instancia, sea $\text{mst\_cost}$ este mínimo costo y sea $\text{sol\_cost}$ el costo encontrado por el algoritmo a evaluar; la puntuación para esa instancia será:

$$100 \times \frac{\text{mst\_cost}}{\text{sol\_cost}}$$

A continuación se muestra la descripción detallada sobre cada grupo:

\begin{center}
 \begin{tabular}{|c|c|c|c|c|}
   \hline
    \multirow{2}{*}{\bf{Grupos}} &
    \multicolumn{2}{c|}{\bf{Restricciones adicionales}} &
    \multirow{2}{*}{\bf{Puntos}} &
    \multirow{2}{*}{\bf{Tests}} \\ \cline{2-3}
      & $n$ & $a_{i,j}$ & & \\ \hline
    \texttt{maxN6} & $2 \le n \le 6$ & --- & $2500$ & $25$ \\ \hline
    \texttt{maxN9} & $7 \le n \le 9$ & --- & $3000$ & $30$ \\ \hline
    \texttt{N10} & $n=10$ & --- & $1000$ & $10$ \\ \hline
    \texttt{N11} & $n=11$ & --- & $1000$ & $10$ \\ \hline
    \texttt{N12} & $n=12$ & --- & $1500$ & $15$ \\ \hline
    \texttt{N13} & $n=13$ & --- & $1500$ & $15$ \\ \hline
    \texttt{N14} & $n=14$ & --- & $1500$ & $15$ \\ \hline
    \texttt{N15} & $n=15$ & --- & $1500$ & $15$ \\ \hline
    \texttt{random1} & $16 \le n \le 30$ & --- & $3000$ & $30$ \\ \hline
    \texttt{random2} & $31 \le n \le 50$ & --- & $3000$ & $30$ \\ \hline
    \texttt{random3} & $51 \le n \le 70$ & --- & $5000$ & $50$ \\ \hline
    \texttt{random4} & $71 \le n \le 100$ & --- & $5000$ & $50$ \\ \hline
 \end{tabular}
\end{center}

Las instancias de prueba utilizadas corresponden a grafos completos de distintos tamaños representados en matriz de adyacencia ponderada. Cada instancia tiene el siguiente formato:
\begin{itemize}
\item La primera línea contiene dos enteros $n$ y $k$ ($1 \le k < n \le 100$) --- la cantidad de edificios y el número máximo de conexiones que soporta cada edificio, respectivamente.
\item Las siguientes $n$ líneas contienen cada una $n$ enteros. El entero $j$ de la fila $i$, denotado por $a_{i,j}$ ($0 \le a_{i,j} \le 100$) representa el costo de instalar un cable de fibra óptica entre el edificio $i$ y el edificio $j$.
\item Se garantiza que $a_{i,i} = 0$ para todo $1 \le i \le n$ y que $a_{i,j} = a_{j,i}$ para todo $1 \le i, j \le n$.
\end{itemize}

La salida de cada algoritmo debe tener el siguiente formato:

\begin{itemize}
    \item La primera línea debe contener un entero $c$ --- el mínimo costo posible.
    \item Le deben seguir $n-1$ líneas. La línea $i$ de ellas debe contener tres enteros $u_i$, $v_i$ y $w_i$ ($1 \le u_i, v_i \le n$, $u_i \neq v_i$, $1 \le w_i \le 100$) --- existe una ruta entre los edificios $u_i$ y $v_i$ con costo $w_i$. La instalación formada por estas rutas debe cumplir con las condiciones del problema.
\end{itemize}

\subsection{Experimentación}

Para cada instancia se evaluó el costo mínimo encontrado, así como el tiempo de ejecución de cada algoritmo, permitiendo comparar su desempeño relativo.

El propósito principal de este análisis experimental no es demostrar escalabilidad, sino:
\begin{itemize}
    \item Validar la correctitud de las implementaciones.
    \item Comparar el impacto de distintas estrategias sobre el tiempo de ejecución.
\end{itemize}

La experimentación se realizó en las plataformas Codeforces y Polygon. El tiempo límite máximo de ejecución para cada algoritmo fue de $15000 \text{ms}$ y una memoria límite máxima de $1024 \text{mb}$. 

\subsection{Resultados}

A continuación se presentan los resultados obtenidos para los tres algoritmos deterministas implementados, esta tabla muestra la cantidad de puntos obtenidos por cada algoritmo y el tiempo límite máximo en cada grupo.

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
\multirow{2}{*}{\bf{Grupos}} 
  & \multicolumn{2}{c|}{\bf{bitmask}}
  & \multicolumn{2}{c|}{\bf{comb}}
  & \multicolumn{2}{c|}{\bf{gray\_recursive}} \\ \cline{2-7}

 & \bf{Puntos} & \bf{Tiempo máx}
 & \bf{Puntos} & \bf{Tiempo máx}
 & \bf{Puntos} & \bf{Tiempo máx} \\ \hline

\texttt{maxN6}   & $2500$ & $31$ & $2500$ & $46$ & $2500$ & $46$  \\ \hline
\texttt{maxN9}   & $2000$ & $15000$ & $3000$ & $14890$ & $3000$ & $7406$ \\ \hline
\texttt{N10}     & $0$ & $15000$ &  $0$ & $15000$  & $148$ & $15000$ \\ \hline
\texttt{N11}     & --- & --- & --- & ---  & $0$ & $15000$ \\ \hline
\texttt{N12}     & --- & --- & --- & ---  & --- & ---  \\ \hline
\texttt{N13}     & --- & --- & --- & ---  & --- & --- \\ \hline
\texttt{N14}     & --- & --- & --- & ---  & --- & --- \\ \hline
\texttt{N15}     & --- & --- & --- & ---  & --- & --- \\ \hline
\texttt{random1} & --- & --- & --- & ---  & --- & --- \\ \hline
\texttt{random2} & --- & --- & --- & ---  & --- & --- \\ \hline
\texttt{random3} & --- & --- & --- & ---  & --- & --- \\ \hline
\texttt{random4} & --- & --- & --- & ---  & --- & --- \\ \hline
\texttt{total} & $4500$ & $15000$ & $5500$ & $15000$  & $5648$ & $15000$ \\ \hline

\end{tabular}
\end{center}


De acuerdo con la tabla de comparación de algoritmos (\texttt{bitmask}, \texttt{comb} y \texttt{gray\_recursive}) se observan los siguientes resultados:

\begin{itemize}
    \item \textbf{Cobertura de grupos:} 
    \texttt{bitmask} y \texttt{comb} funcionan correctamente únicamente en los grupos más pequeños (\texttt{maxN6} y \texttt{maxN9}). 
    \texttt{gray\_recursive} es el único algoritmo que obtiene resultados en los grupos medianos (\texttt{N10} y \texttt{N11}), aunque con tiempos máximos cercanos al límite permitido. 
    Ninguno de los algoritmos logró resolver los grupos más grandes (\texttt{N12}--\texttt{N15} y \texttt{random1}--\texttt{random4}), mostrando limitaciones de escalabilidad.
    
    \item \textbf{Puntos obtenidos:} 
    En \texttt{maxN6}, los tres algoritmos alcanzan la puntuación máxima (2500 puntos), indicando desempeño completo en instancias pequeñas. 
    Para \texttt{maxN9}, \texttt{bitmask} alcanza solo 2000 puntos, mientras que \texttt{comb} y \texttt{gray\_recursive} logran 3000 puntos, mostrando que \texttt{bitmask} pierde eficiencia en instancias medianas. 
    En \texttt{N10}, únicamente \texttt{gray\_recursive} obtuvo 148 puntos, mientras que los otros dos algoritmos no lograron puntos.
    
    \item \textbf{Tiempo máximo:} 
    Todos los algoritmos alcanzaron o se aproximaron al tiempo límite (15000 ms) en las instancias más grandes y medianas, lo que indica que estas implementaciones no escalan bien y que los tiempos son críticos para instancias mayores a $n=9$.
    
    \item \textbf{Resumen total:} 
    Sumando los puntos obtenidos por cada algoritmo, \texttt{gray\_recursive} alcanza la puntuación más alta total (5648 puntos), seguido por \texttt{comb} (5500) y \texttt{bitmask} (4500). Esto refleja que \texttt{gray\_recursive} es más robusto frente a instancias medianas, aunque sigue limitado en instancias grandes.
\end{itemize}

A continuación se presentan los resultados obtenidos para los algoritmos heurísticos implementados, esta tabla muestra la cantidad de puntos obtenidos por cada algoritmo y el tiempo límite máximo en cada grupo.

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
\multirow{2}{*}{\bf{Grupos}} 
  & \multicolumn{2}{c|}{\bf{evolutionary}}
  & \multicolumn{2}{c|}{\bf{ant\_colony200}}
  & \multicolumn{2}{c|}{\bf{ant\_colony100}} \\ \cline{2-7}

 & \bf{Puntos} & \bf{Tiempo máx}
 & \bf{Puntos} & \bf{Tiempo máx}
 & \bf{Puntos} & \bf{Tiempo máx} \\ \hline

\texttt{maxN6}   & $2500$ & $140$ & $2500$ & $203$ & $2500$ & $93$  \\ \hline
\texttt{maxN9}   & $2990$ & $265$ & $3000$ & $281$ & $2995$ & $171$ \\ \hline
\texttt{N10}     & $921$ & $359$ &  $945$ & $375$  & $945$ & $234$ \\ \hline
\texttt{N11}     & $895$ & $375$ & $970$ & $531$  & $970$ & $265$ \\ \hline
\texttt{N12}     & $1275$ & $421$ & $1429$ & $687$  & $1424$ & $390$  \\ \hline
\texttt{N13}     & $1321$ & $468$ & $1417$ & $906$  & $1416$ & $484$ \\ \hline
\texttt{N14}     & $1302$ & $531$ & $1450$ & $1187$  & $1450$ & $609$ \\ \hline
\texttt{N15}     & $1197$ & $609$ & $1426$ & $1593$  & $1426$ & $765$ \\ \hline
\texttt{random1} & $2314$ & $2453$ & $2945$ & $12625$  & $2941$ & $7187$ \\ \hline
\texttt{random2} & $1691$ & $7828$ & $233$ & $15000$  & $1230$ & $15000$ \\ \hline
\texttt{random3} & $2342$ & $15000$ & $0$ & $15000$  & $0$ & $15000$ \\ \hline
\texttt{random4} & $20$ & $15000$ & $0$ & $15000$  & $0$ & $15000$ \\ \hline
\texttt{total} & $18768$ & $15000$ & $16315$ & $15000$  & $17297$ & $15000$ \\ \hline

\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
\multirow{2}{*}{\bf{Grupos}} 
  & \multicolumn{2}{c|}{\bf{ant\_colony50}}
  & \multicolumn{2}{c|}{\bf{ant\_colony25}}
  & \multicolumn{2}{c|}{\bf{ant\_colony12}} \\ \cline{2-7}

 & \bf{Puntos} & \bf{Tiempo máx}
 & \bf{Puntos} & \bf{Tiempo máx}
 & \bf{Puntos} & \bf{Tiempo máx} \\ \hline

\texttt{maxN6}   & $2500$ & $93$ & $2500$ & $46$ & $2500$ & $31$  \\ \hline
\texttt{maxN9}   & $2995$ & $109$ & $2995$ & $62$ & $2995$ & $62$ \\ \hline
\texttt{N10}     & $945$ & $140$ &  $945$ & $93$  & $945$ & $62$ \\ \hline
\texttt{N11}     & $970$ & $156$ & $970$ & $125$  & $967$ & $62$ \\ \hline
\texttt{N12}     & $1424$ & $203$ & $1424$ & $125$  & $1422$ & $78$  \\ \hline
\texttt{N13}     & $1417$ & $265$ & $1417$ & $156$  & $1409$ & $93$ \\ \hline
\texttt{N14}     & $1450$ & $312$ & $1447$ & $187$  & $1446$ & $109$ \\ \hline
\texttt{N15}     & $1426$ & $406$ & $1426$ & $203$  & $1426$ & $125$ \\ \hline
\texttt{random1} & $2942$ & $3578$ & $2940$ & $1765$  & $2937$ & $937$ \\ \hline
\texttt{random2} & $2225$ & $15000$ & $2925$ & $9250$  & $2924$ & $4546$ \\ \hline
\texttt{random3} & $0$ & $15000$ & $2262$ & $15000$  & $4955$ & $12984$ \\ \hline
\texttt{random4} & $0$ & $15000$ & $0$ & $15000$  & $356$ & $15000$ \\ \hline
\texttt{total} & $18294$ & $15000$ & $21251$ & $15000$  & $24282$ & $15000$ \\ \hline

\end{tabular}
\end{center}

Se presentan los resultados de comparación de los algoritmos \texttt{evolutionary} y variantes de \texttt{ant\_colony} con diferentes parámetros de población.

\begin{itemize}
    \item \textbf{Cobertura de grupos:}
    Todos los algoritmos obtienen resultados completos en los grupos más pequeños (\texttt{maxN6} y \texttt{maxN9}). A medida que el tamaño de las instancias aumenta, los algoritmos comienzan a diferenciarse: \texttt{evolutionary} mantiene puntuaciones consistentes hasta \texttt{N15} y \texttt{random1}, pero pierde eficacia en \texttt{random2--random4}. Las versiones de \texttt{ant\_colony} muestran un comportamiento dependiente del tamaño de población: las colonias mayores (200, 100) alcanzan mejores resultados en instancias medianas, mientras que las colonias más pequeñas (50, 25, 12) obtienen puntuaciones más bajas en los grupos grandes.

    \item \textbf{Puntos obtenidos:}
    \begin{itemize}
        \item En los grupos pequeños y medianos (\texttt{maxN6}--\texttt{N15}), todos los algoritmos alcanzan puntuaciones altas y consistentes, aunque \texttt{ant\_colony200} y \texttt{ant\_colony100} superan ligeramente a \texttt{evolutionary} en algunos casos (\texttt{N12--N15}).
        \item Para instancias grandes y aleatorias (\texttt{random1--random4}), la puntuación total aumenta conforme se incrementa la población de la colonia de hormigas: por ejemplo, \texttt{ant\_colony12} obtiene 24282 puntos totales frente a 18294 de \texttt{ant\_colony50}.
        \item En general, \texttt{ant\_colony12} y \texttt{ant\_colony25} muestran que con una configuración adecuada se pueden superar los resultados de \texttt{evolutionary} en instancias grandes.
    \end{itemize}

    \item \textbf{Tiempo máximo:}
    \begin{itemize}
        \item Los tiempos de \texttt{evolutionary} son moderados en instancias pequeñas y medianas, pero alcanzan 15000 ms (tiempo límite) en las instancias más grandes (\texttt{random3--random4}).
        \item Las versiones de \texttt{ant\_colony} muestran un comportamiento dependiente de la población: colonias grandes tardan más (hasta 15000 ms en algunos casos), mientras que colonias pequeñas reducen significativamente el tiempo, aunque algunas puntuaciones disminuyen.
        \item Existe un trade-off claro entre tamaño de población y tiempo de ejecución: mayor población → mejores resultados pero mayor tiempo; menor población → resultados más rápidos pero potencialmente menores.
    \end{itemize}

    \item \textbf{Resumen total:}
    \begin{itemize}
        \item En puntuación total acumulada, \texttt{ant\_colony12} es el algoritmo más efectivo (24282 puntos), seguido por \texttt{ant\_colony25} (21251) y \texttt{evolutionary} (18768).
        \item Esto indica que, aunque \texttt{evolutionary} es estable y consistente, las variantes de colonia de hormigas bien parametrizadas superan el rendimiento en instancias grandes.
    \end{itemize}
\end{itemize}

% \begin{figure}[H]
%     \centering
%     \includegraphics[width=1\textwidth]{tiempo_vs_V_K_2.png}
%     \caption{Resultados de soluciones deterministas para K = 2}
%     \label{fig:resultados_k2}
% \end{figure}

% \begin{figure}[H]
%     \centering
%     \includegraphics[width=1\textwidth]{tiempo_vs_V_K_3.png}
%     \caption{Resultados de soluciones deterministas para K = 3}
%     \label{fig:resultados_k3}
% \end{figure}

% \begin{figure}[H]
%     \centering
%     \includegraphics[width=1\textwidth]{tiempo_vs_V_K_4.png}
%     \caption{Resultados de soluciones deterministas para K = 4}
%     \label{fig:resultados_k4}
% \end{figure}

\section{Conclusiones}
En este trabajo se detalló el análisis y solución del problema DCMST. Se demostró su complejidad NP-Hard y se presentaron cuatro variantes algorítmicas exactas para su resolución.

\newpage
% \appendix
% \section{Apéndice: Implementaciones en C++}

% A continuación se presentan las implementaciones completas utilizadas en el estudio.

% \subsection{Solución 1: Fuerza Bruta con Máscara de Bits} \label{sec:code_bitmask}
% \lstinputlisting[
%     language=C++
% ]{../src/solutions/bitmask.cpp}


% \subsection{Solución 2: Generación Combinatoria Lexicográfica} \label{sec:code_comb}
% \lstinputlisting[
%     language=C++
% ]{../src/solutions/comb.cpp}

% \subsection{Solución 3: Código de Gray Iterativo} \label{sec:code_gray_iter}
% \lstinputlisting[
%     language=C++
% ]{../src/solutions/gray_iterative.cpp}


% \subsection{Solución 4: Código de Gray Recursivo con Poda} \label{sec:code_gray_rec}
% \lstinputlisting[
%     language=C++
% ]{../src/solutions/gray_recursive.cpp}

\begin{thebibliography}{9}
\bibitem{clrs} 
Cormen, T. H., Leiserson, C. E., Rivest, R. L., \& Stein, C. (2009). 
\textit{Introduction to Algorithms} (3rd ed., Chapter 34). 
MIT Press.

\bibitem{evol2000}
J. Knowles and D. Corne. 2000. A new evolutionary approach to the degree-constrained minimum spanning tree problem. Trans. Evol. Comp 4, 2 (July 2000), 125-134.

\bibitem{ant2019}
Wanru Gao, Mojgan Pourhassan, Vahid Roostapour, and Frank Neumann. 2019. Runtime Analysis of Evolutionary Multi-objective Algorithms Optimising the Degree and Diameter of Spanning Trees. In Evolutionary Multi-Criterion Optimization: 10th International Conference, EMO 2019, East Lansing, MI, USA, March 10-13, 2019, Proceedings. Springer-Verlag, Berlin, Heidelberg, 504-515.

\end{thebibliography}

\end{document}