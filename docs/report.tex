\documentclass[10pt]{article}

% --- Paquetes Básicos ---
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath, amssymb, amsthm, amsfonts}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}

% --- Configuración de Márgenes ---
\geometry{margin=1in}

% --- Definición de Operadores Matemáticos ---
\DeclareMathOperator*{\argmin}{arg\,min}
\newtheorem{definition}{Definición}
\newtheorem{theorem}{Teorema}
\newtheorem{lemma}[theorem]{Lema}    % Lemma shares counter with theorem

% --- Configuración para Código C++ ---
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\lstset{
    language=C++,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{codegreen},
    stringstyle=\color{codepurple},
    breaklines=true,
    numbers=left,
    numberstyle=\tiny\color{codegray}
}

\usepackage{amsthm} % Load the theorem package


% --- Información del Proyecto ---
\title{Optimización de Red de Fibra Óptica \\ (Degree-Constrained Minimum Spanning Tree) \\ \large Diseño y Análisis de Algoritmos - Universidad de La Habana}
\author{Ernesto Abreu Peraza, Eduardo Brito Labrada}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Este informe detalla el análisis y la solución al problema del Árbol de Expansión Mínimo con Grado Restringido (DCMST) para la infraestructura de red de la Universidad de La Habana. Se presenta la formalización matemática, la demostración de su complejidad NP-Hard y una comparativa experimental entre diferentes algoritmos implementados en C++.
\end{abstract}

\newpage
\tableofcontents
\newpage

\section{Formalización del Problema}
Partiendo de la necesidad de interconectar los edificios de la universidad minimizando costos y respetando la capacidad de puertos de ETECSA, definimos el modelo matemático.

\subsection{Modelo Matemático}
Sea $G = (V, E)$ un grafo conexo y no dirigido, donde:
\begin{itemize}
    \item $V$ es el conjunto de edificios.
    \item $E$ es el conjunto de posibles conexiones de fibra.
    \item $w: E \to \mathbb{R}^+$ es una función de costo.
    \item $k: V \to \mathbb{N}$ es la capacidad de puertos por edificio.
\end{itemize}

El problema consiste en encontrar un subgrafo $T = (V, E')$ tal que:
\begin{equation}
    T^* = \argmin_{T \in \mathcal{T}} \sum_{e \in E'} w(e)
\end{equation}
Sujeto a:
\begin{enumerate}
    \item $T$ es un árbol de expansión de $G$.
    \item $\forall v \in V, \text{deg}_T(v) \leq k(v)$.
\end{enumerate}

Este problema es conocido como \textit{Degree-Constrained Minimum Spanning Tree} (DCMST).

\section{Análisis de Complejidad Computacional}
\subsection{Demostración de NP-Hardness}
Para demostrar que el problema es NP-Hard, realizamos una reducción desde el problema \textit{Hamiltonian Path}, un conocido problema NP-Completo. 
\begin{theorem}
El problema DCMST es NP-Hard.
\end{theorem}
\begin{proof}
Dada una instancia del problema \textit{Hamiltonian Path}, construimos una instancia del problema DCMST donde cada vértice tiene grado máximo 2. Si existe un árbol de expansión que cumpla las restricciones de grado,
entonces tenemos un camino de hamilton del grafo original.

Si supieramos resolver DCMST en tiempo polinomial, podríamos resolver \textit{Hamiltonian Path} en tiempo polinomial.

Por lo tanto, DCMST es NP-Hard.
\end{proof}

\subsection{Degree-Constrained Spanning Tree}

El problema de decisión Degree-Constrained Spanning Tree (DCST), en el cual queremos saber si existe un árbol de expansión que cumpla con las restricciones de grado, es NP-Completo. 
Ya que es fácil verificar que un árbol dado es de expansión de $G$ y cumple con las restricciones de grado en tiempo polinomial.

\section{Diseño de Soluciones Algorítmicas}

\subsection{Enumeración con Máscara de Bits para el DCMST}

Esta es una solución exacta para el problema DCMST basada en \textbf{enumeración exhaustiva mediante máscara de bits}. Esta solución está diseñada para instancias de tamaño pequeño, sirviendo como algoritmo de referencia y verificación de metaheurísticas.

El algoritmo explora todos los subconjuntos posibles de aristas que contienen exactamente $|V| - 1$ aristas y verifica cuáles inducen un árbol generador que cumple con la restricción de grado. Entre todas las soluciones factibles, selecciona la de costo mínimo.

\subsubsection{Descripción del Algoritmo}

Sea $G = (V, E)$ un grafo completo, no dirigido y ponderado, con $|V| = n$ vértices y $|E| = m = \dfrac{n(n-1)}{2}$ aristas. El algoritmo procede de la siguiente manera:

\begin{enumerate}
    \item Se enumeran todas las aristas $E$ y se indexan de $0$ a $m-1$.
    \item Se recorre cada máscara de bits $mask \in \{0,1\}^m$.
    \item Solo se consideran las máscaras cuyo número de bits activos es exactamente $n-1$.
    \item Cada máscara define un subgrafo $G_{mask}$ compuesto por las aristas seleccionadas.
    \item Se verifica si:
    \begin{itemize}
        \item El subgrafo es conexo (usando Depth-First Search).
        \item El grado de cada vértice es a lo sumo $k$.
    \end{itemize}
    \item Si ambas condiciones se cumplen, el sugrafo es un árbol generador factible y se evalúa su costo.
    \item Se devuelve el mínimo costo entre todas las soluciones factibles.
\end{enumerate}

El uso de una máscara de bits permite representar subconjuntos de aristas de forma compacta y eficiente a nivel de implementación.

\subsubsection{Análisis de Correctitud}

Demostraremos que el algoritmo es correcto, es decir, que devuelve exactamente el costo del árbol generador mínimo con restricción de grado.

\begin{lemma}\label{lem:exhaustivity1}
    El algoritmo examina \textbf{todos} los subconjuntos de aristas de tamaño $n-1$.
\end{lemma}
\begin{proof}
    Cada máscara de bits $m$ representa un subconjunto único de aristas. Al iterar sobre todas las máscaras
    con $\text{popcount(mask)} = n-1$, se enumeran exactamente todos los subconjuntos de $E$ con $n-1$ aristas.
\end{proof}

\begin{lemma}\label{lem:factible_dcst1}
    Un subconjunto de aristas $E' \subseteq E$ con $|E'| = n-1$ es un árbol generador factible si y solo si:
    \begin{enumerate}
        \item El grafo inducido es conexo.
        \item Para todo vértice $v$, $\text{deg}(v) \le k$.
    \end{enumerate}
\end{lemma}
\begin{proof}
    Un grafo conexo con $n-1$ aristas es un árbol. La segunda condición garantiza la restricción de grado. Por lo tanto, ambas condiciones son necesarias y suficientes. 
\end{proof}

\begin{lemma}
    La función \texttt{check} devuelve verdadero si y solo si el subgrafo inducido por la máscara es un árbol generador factible.
\end{lemma}
\begin{proof}
    Inicialmente, verifica que ningún vértice tenga grado mayor que $k$. Luego, ejecuta un DFS desde el vértice $0$ y comprueba que todos los vértices son alcanzables, lo que implica conectividad. Por el Lema \ref{lem:factible_dcst1}, esto es equivalente a ser un DCST factible.
\end{proof}

\begin{theorem}
    El algoritmo devuelve el costo mínimo entre todos los árboles generadores que cumplen la restricción de grado.
\end{theorem}
\begin{proof}
    Por el Lema \ref{lem:exhaustivity1}, el algoritmo considera todas las soluciones candidatas. Por el Lema \ref{lem:factible_dcst}, acepta exactamente las soluciones factibles. Finalmente, toma el mínimo costo entre ellas. Por lo tanto, el resultado es óptimo.
\end{proof}

\subsubsection{Análisis de Complejidad}

El número total de máscaras es $2^m$, pero las máscaras consideradas efectivamente son $\binom{m}{n-1}$ y por cada una de ellas se hace lo siguiente:
\begin{itemize}
    \item Construcción del subgrafo: $O(n)$.
    \item Verificación de grados: $O(n)$.
    \item DFS para conectividad: $O(n)$.
\end{itemize}

Por tanto, el costo por máscara es $O(n)$ y la complejidad total es: $O(2^m + \binom{m}{n-1} \cdot n)$.


\subsection{Enumeración Lexicográfica para el DCMST}

El algoritmo se basa en la enumeración exhaustiva de subconjuntos de aristas mediante una representación binaria y generación lexicográfica de combinaciones. Su aplicabilidad es sobre todo para instancias de tamaño reducido y es aplicable como algoritmo de referencia para la validación de metaheurísticas.

\subsubsection{Descripción del Algoritmo}

Sea $G = (V,E)$ un grafo completo con $|V| = n$ vértices y $|E| = m = \frac{n(n-1)}{2}$ aristas. El algoritmo procede como sigue:

\begin{enumerate} 
    \item Se indexan todas las aristas de $E$. 
    \item Se construye una cadena binaria \texttt{state} de longitud $m$ con exactamente $n-1$ bits activos. 
    \item Cada permutación lexicográfica de \texttt{state} representa un subconjunto distinto de $n-1$ aristas. 
    \item Para cada subconjunto: 
    \begin{itemize} 
        \item Se construye el subgrafo inducido. 
        \item Se verifica la restricción de grado. 
        \item Se comprueba conectividad mediante DFS. 
        \item Si es factible, se evalúa su costo. 
    \end{itemize} 
    \item Se devuelve el mínimo costo encontrado. 
\end{enumerate}

La generación de subconjuntos se realiza mediante la función \texttt{next\_permutation}, lo que garantiza que cada combinación se visita exactamente una vez.

\subsubsection{Análisis de Correctitud}

\begin{lemma}\label{lem:exhaustivity2}
    El algoritmo enumera todos los subconjuntos de aristas de tamaño $n-1$.
\end{lemma}
\begin{proof}
    La cadena binaria inicial contiene exactamente $n-1$ unos y $m-(n-1)$ ceros. El uso de \texttt{next\_permutation} genera todas las permutaciones distintas de dicha cadena, que corresponden biyectivamente a los subconjuntos de $E$ con $n-1$ elementos.
\end{proof}

\begin{lemma}\label{lem:factible_dcst2}
    Un subconjunto $E' \subseteq E$ con $|E'|=n-1$ es un árbol generador factible si y solo si: 
    \begin{enumerate} 
        \item El subgrafo inducido es conexo. 
        \item Para todo $v \in V$, $\deg(v) \leq k$. 
    \end{enumerate}
\end{lemma}
\begin{proof}
    Un grafo conexo con $n-1$ aristas es un árbol. La segunda condición garantiza la restricción de grado. Ambas son necesarias y suficientes.
\end{proof}

\begin{lemma}
    La función \texttt{check} devuelve verdadero si y solo si el subgrafo inducido por la máscara es un árbol generador factible.
\end{lemma}
\begin{proof}
    Inicialmente, verifica que ningún vértice tenga grado mayor que $k$. Luego, ejecuta un DFS desde el vértice $0$ y comprueba que todos los vértices son alcanzables, lo que implica conectividad. Por el Lema \ref{lem:factible_dcst2}, esto es equivalente a ser un DCST factible.
\end{proof}

\begin{theorem}
    El algoritmo devuelve el costo mínimo entre todos los árboles generadores que satisfacen la restricción de grado.    
\end{theorem}
\begin{proof}
    Por el Lema \ref{lem:exhaustivity2}, todas las soluciones candidatas son evaluadas. Por el Lema \ref{lem:factible_dcst2}, se aceptan exactamente las factibles. El algoritmo selecciona el mínimo costo entre ellas, lo que implica optimalidad.
\end{proof}

\subsubsection{Análisis de Complejidad}

El número de combinaciones evaluadas es: $\binom{m}{n-1}$ y para cada combinación:
\begin{itemize} 
    \item Construcción del subgrafo: $O(n)$. 
    \item Verificación de grados: $O(n)$. 
    \item DFS de conectividad: $O(n)$. 
\end{itemize}

Por lo tanto, la complejidad es $O(\binom{m}{n-1} \cdot n)$.

\section{Implementación y Análisis Experimental}
\section{Conclusiones}

\newpage

\begin{thebibliography}{9}
\bibitem{clrs} 
Cormen, T. H., Leiserson, C. E., Rivest, R. L., \& Stein, C. (2009). 
\textit{Introduction to Algorithms} (3rd ed., Chapter 34). 
MIT Press.
\end{thebibliography}

\end{document}